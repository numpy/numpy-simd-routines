import subprocess
import textwrap
import tempfile
import os
import re


def sollya(expr, as_int=None):
    """Sollya wrapper with comprehensive message filtering using temp file"""
    expr = textwrap.dedent(expr).strip()
    # Create temporary file
    with tempfile.NamedTemporaryFile(mode="w", suffix=".sollya", delete=False) as f:
        f.write(expr + "\nquit;\n")
        temp_file = f.name

    try:
        # Execute Sollya with temp file
        result = subprocess.run(["sollya", temp_file], capture_output=True, text=True)

        # Define patterns to filter out
        ignore_patterns = [
            r"^Warning",  # Warnings
            r"^The precision has been set",  # Precision messages
            r"^Display mode is ",  # Default precision messages
            r"^\s*$",  # Empty lines
        ]

        lines = result.stdout.strip().split("\n")
        filtered = []

        for line in lines:
            line = line.strip()
            if line:
                # Check if line matches any ignore pattern
                should_ignore = any(
                    re.match(pattern, line) for pattern in ignore_patterns
                )
                if not should_ignore:
                    filtered.append(line)
        if as_int:
            return [int(l, base=as_int) for l in filtered]
        return filtered

    finally:
        # Clean up temp file
        os.unlink(temp_file)


def gen_reduction(float_size=64):
    """
    Precompute int(2^exp × 4/π) with ~96-bit precision (f32) or ~192-bit precision (f64)
    and split them into three chunks: 32-bit chunks for single precision, 64-bit chunks for double precision.

    This generates a lookup table for large range reduction in trigonometric functions.
    The table is used to compute mantissa × (2^exp × 4/π) using wider integer multiplications for precision:
    - f32: 16×16 → 32-bit multiplications
    - f64: 32×32 → 64-bit multiplications

    For input x = mantissa × 2^exp, the algorithm becomes:
    x × 4/π = mantissa × table_lookup[exp], providing high precision without floating-point errors.

    Args:
        float_size: 32 for f32 or 64 for f64
    """
    exp = (1 << (8 if float_size == 32 else 11)) - 1
    offset, usfx = (70, "U") if float_size == 32 else (137, "ULL")
    bias = exp >> 1
    ints = sollya(
        f"""
    prec = {float_size * 3 * 3}; 
    four_over_pi = 4 / pi;
    for e from 0 to {exp} do {{ 
        e_shift = e - {bias} + {offset}; 
        floor(four_over_pi * (2^e_shift));
    }};
    """,
        as_int=10,
    )
    chunk_mask = (1 << float_size) - 1
    chunks = [
        hex((i >> shift) & chunk_mask) + usfx
        for i in ints
        for shift in [float_size * 2, float_size, 0]
    ]
    return chunks


def gen_approx(float_size=64, func="sin", func_driv="cos"):
    n = 1 << (8 if float_size == 32 else 11)
    cast = "single" if float_size == 32 else "double"
    return sollya(
        f"""
    prec = {float_size*3}; 
    display = hexadecimal;
    cast = {cast}(x);
    func = {func}(x);
    scale = 2.0 * pi / {n};
    for e from 0 to {n - 1} do {{ 
        theta = e * scale;
        p1 = cast(func(theta));
        p2 = cast(func(theta) - p1);
        deriv = {func_driv}(theta);
        k = nearestint(log2(abs(deriv)));
        if (deriv < 0) then sign = -1 else sign = 1;
        p3 = sign * 2.0^k;
        p0 = cast(deriv - p3);
        p0;p1;p2;p3;
    }};
    """
    )


def gen_kpi16(float_size=64, func="sin"):
    cast = "single" if float_size == 32 else "double"
    return sollya(
        f"""
    prec = {float_size*3}; 
    display = hexadecimal;
    cast = {cast}(x);
    func = {func}(x);
    pi16 = pi / 16;
    for k from 0 to 15 do {{
        cast(func(k * pi16));
    }};
    """
    )


def gen_pack_func(clo, slo):
    combined = (clo & 0xFFFFFFFF00000000) | ((slo >> 32) & 0xFFFFFFFF)
    return f"0x{combined:016x}"


def gen_kpi16_low_pack():
    ints = sollya(
        f"""
    prec = {64*3}; 
    display = hexadecimal;
    pi16 = pi / 16;
    for k from 0 to 15 do {{
        shi = double(sin(k * pi16));
        chi = double(cos(k * pi16));
        slo = double(sin(k * pi16) - shi);
        clo = double(cos(k * pi16) - chi);
        printdouble(clo);
        printdouble(slo);
    }};
    """,
        as_int=0x10,
    )
    packed = [gen_pack_func(clo, slo) for clo, slo in zip(ints[::2], ints[1::2])]
    ints = sollya(
        f"""
    prec = {64*3}; 
    display = hexadecimal;
    packed = [|{','.join(packed)}|];
    for k from 0 to 15 do {{
        double(packed[k]);
    }};
    """
    )
    return ints


nl = ",\n"
print(
    """\
// auto generated by npsr/sincos/lut-inl.h.py
#include <cstdint>
#if defined(NPSR_TRIG_LUT_INL_H_) == defined(HWY_TARGET_TOGGLE) // NOLINT
#ifdef NPSR_TRIG_LUT_INL_H_
#undef NPSR_TRIG_LUT_INL_H_
#else
#define NPSR_TRIG_LUT_INL_H_
#endif

HWY_BEFORE_NAMESPACE();

namespace npsr::HWY_NAMESPACE::sincos {
HWY_API void DummySupressUnusedTargetWarn();


template <typename T> constexpr T kLargeReductionTable[] = {};
template <typename T> constexpr T kSinApproxTable[] = {};
template <typename T> constexpr T kCosApproxTable[] = {};
template <typename T> constexpr T kHiSinKPi16Table[] = {};
template <typename T> constexpr T kHiCosKPi16Table[] = {};
template <typename T> constexpr T kPackedLowSinCosKPi16Table[] = {};
"""
)
print(
    f"""\
template <> HWY_ALIGN constexpr double kHiSinKPi16Table<double>[] = {{
{nl.join(gen_kpi16(func="sin"))}
}};
template <> HWY_ALIGN constexpr double kHiCosKPi16Table<double>[] = {{
{nl.join(gen_kpi16(func="cos"))}
}};
template <> HWY_ALIGN constexpr double kPackedLowSinCosKPi16Table<double>[] = {{
{nl.join(gen_kpi16_low_pack())}
}};\
"""
)
for fsize, T in ((32, "float"), (64, "double")):
    print(
        f"""\
template <> HWY_ALIGN constexpr uint{fsize}_t kLargeReductionTable<{T}>[] = {{
{nl.join(gen_reduction(fsize))}
}};
template <> HWY_ALIGN constexpr {T} kSinApproxTable<{T}>[] = {{
{nl.join(gen_approx(fsize, "sin", "cos"))}
}};
template <> HWY_ALIGN constexpr {T} kCosApproxTable<{T}>[] = {{
{nl.join(gen_approx(fsize, "cos", "-sin"))}
}};\
    """
    )
print(
    """
} // namespace npsr::HWY_NAMESPACE::sincos
HWY_AFTER_NAMESPACE();
#endif // NPSR_TRIG_LUT_INL_H_
"""
)
