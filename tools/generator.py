#!/usr/bin/env python3

import subprocess
import textwrap
import tempfile
import os
import re
import pathlib
import glob
import runpy
import sys
import inspect
from itertools import chain

curdir = pathlib.Path(__file__).parent
rootdir = curdir.parent
sys.path.insert(0, str(curdir))


def sollya(expr, as_int=None, from_path=None, dump=False, encoding="utf-8"):
    """Sollya wrapper with comprehensive message filtering using temp file"""
    expr = textwrap.dedent(expr).strip()
    # Create temporary file
    with tempfile.NamedTemporaryFile(
        mode="w", suffix=".sollya", delete=False, encoding=encoding
    ) as f:
        f.write(expr + "\n")
        if from_path:
            with open(from_path, "r", encoding=encoding) as rf:
                f.write(rf.read().strip())
                f.write("\n")
        temp_file = f.name

    try:
        # Execute Sollya with temp file
        result = subprocess.run(["sollya", temp_file], capture_output=True, text=True)
        if dump:
            with open(temp_file, "r") as f:
                raise TypeError(f.read() + "-" * 20 + result.stdout.strip())
        # Define patterns to filter out
        ignore_patterns = [
            r"^Warning",  # Warnings
            r"^The precision has been set",  # Precision messages
            r"^Display mode is ",  # Default precision messages
            r"^\s*$",  # Empty lines
        ]

        lines = result.stdout.strip().split("\n")
        filtered = []

        for line in lines:
            line = line.strip()
            if line:
                # Check if line matches any ignore pattern
                should_ignore = any(
                    re.match(pattern, line) for pattern in ignore_patterns
                )
                if not should_ignore:
                    filtered.append(line)
        if as_int:
            return [int(num, base=as_int) for num in filtered]
        return filtered

    finally:
        # Clean up temp file
        os.unlink(temp_file)


def c_header(*lines, namespace, inspect_idx=1):
    """Generate C++ header with optional namespace"""
    caller_frame = inspect.stack()[inspect_idx]
    caller_filepath = caller_frame.filename
    file = pathlib.Path(caller_filepath).resolve()
    rfile = str(file.relative_to(rootdir))
    guard_name = rfile.upper().replace("/", "_").replace(".", "_").replace("-", "_")
    header = [
        f"// Do not edit this file, it is generated by {rfile}",
        "// use `spin generate -f` to force regeneration",
        f"#ifndef {guard_name}",
        f"#define {guard_name}",
    ]
    header.extend([f"namespace {namespace} {{ namespace {{"])
    header.extend(lines)
    header.append("}} // namespace {namespace}")
    header.append(f"#endif // {guard_name}")
    return "\n".join(header)


def array(data, col, sfx, indent, start, end):
    """Generate a nicely aligned C-style array."""
    # Convert all values to strings with suffix
    str_data = [f"{x}{sfx}," for x in data]
    str_data = ["0.0f," if s == "0f," else s for s in str_data]
    # Determine the max width for each value (for alignment)
    width = max(len(s) for s in str_data)
    pad = " " * indent
    lines = []
    for i in range(0, len(str_data), col):
        chunk = str_data[i : i + col]
        line = " ".join(s.ljust(width) for s in chunk)
        lines.append(pad + line)

    return start + "\n" + "\n".join(lines) + "\n" + end


def py_array(data, col=8, sfx="", indent=4):
    return array(data, col, sfx, indent, "[", "]")


def c_array(data, col=8, sfx="", indent=4):
    return array(data, col, sfx, indent, "{", "};")


def main(force):
    path = rootdir / "npsr"
    patterns = (f"{path}/**/data/*.h.py", f"{path}/**/data/*.py.py")
    files = list(chain.from_iterable(glob.glob(p, recursive=True) for p in patterns))

    for f in files:
        out = f.replace(".h.py", ".h").replace(".py.py", ".py")

        # check if the file exists
        if not force and pathlib.Path(out).exists():
            print(f"Skipping {out}, file already exists")
            continue

        print(f"Generating {out} from {f}")
        with open(out, "w") as fd:
            old_stdout = sys.stdout
            sys.stdout = fd
            try:
                runpy.run_path(f)
            finally:
                sys.stdout = old_stdout


def pad_list(data, pad_length=512):
    """
    Pad a list to make its length a multiple of pad_length by repeating elements from the list itself.

    Required because the C++ testing unit validates:
    - Array size must be >= lane count
    - Array size must be divisible by lane count

    Without padding, arrays get rejected with:
    "each array size must be aligned and >= its lane count"

    Args:
        data (list): Input list to be padded
        pad_length (int): Required alignment boundary (default: 512)

    Returns:
        list: Padded list that passes C++ validation
    """
    if not data:
        return data

    length = len(data)
    remainder = length % pad_length
    if remainder != 0:
        padding_needed = pad_length - remainder
        # Repeat the list cyclically
        padding = (data * ((padding_needed // length) + 1))[:padding_needed]
        data.extend(padding)
    return data


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(
        description="Generate C++ headers/python templates from Python scripts."
    )
    parser.add_argument(
        "-f",
        "--force",
        action="store_true",
        help="Force regenerate all files, even if they already exist.",
    )
    args = parser.parse_args()
    main(force=args.force)
